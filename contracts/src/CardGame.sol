// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "./DummyVRF.sol";

/*
 * Interface for the solidity verifier generated by snarkjs.
 */
interface IVerifier {
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[2] memory input
    ) external view returns (bool);
}

contract CardGame {
    struct Move {
        bool hasPlayed;
        uint256 cardIdx;
    }
    struct Player {
        uint256 randCommit;
        address addr;
        uint256[] moves;
    }

    Player A;
    Player B;
    uint256 nRounds;
    uint256 currentRound;
    uint256 deckSize;
    DummyVRF vrf;
    IVerifier verifierContract;

    event StartRound(uint256 roundIndex);

    constructor(uint256 _nRounds, uint256 deckSize_, address _verifierAddress) {
        nRounds = _nRounds;
        deckSize = deckSize_;

        vrf = new DummyVRF();
        verifierContract = IVerifier(_verifierAddress);
    }

    function attemptStartGame() internal {
        if (A.addr != address(0) && B.addr != address(0)) {
            emit StartRound(currentRound);
        }
    }

    function claimPlayerA(uint256 randCommit) external {
        require(A.addr == address(0), "Player A has already been claimed.");
        A = Player(randCommit, msg.sender, new uint256[](nRounds));
        attemptStartGame();
    }

    function claimPlayerB(uint256 randCommit) external {
        require(A.addr == address(0), "Player B has already been claimed.");
        B = Player(randCommit, msg.sender, new uint256[](nRounds));
        attemptStartGame();
    }

    function getPlayer() internal view returns (Player memory) {
        if (msg.sender == A.addr) {
            return A;
        }
        if (msg.sender == B.addr) {
            return B;
        }
        revert("Sender is not registered for this game.");
    }

    function playCard(uint256 cardIdx) external {
        Player memory player = getPlayer();
        
    }

    modifier 
}
